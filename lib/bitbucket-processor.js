import axios from "axios";
import { promises as fs } from "fs";
import path from "path";
import chalk from "chalk";
import { format } from "date-fns";
import slugify from "slugify";
import { v4 as uuidv4 } from "uuid";
import { ClaudeProcessor } from "./claude-processor.js";

/**
 * Class to handle Bitbucket PR integration
 */
export class BitbucketProcessor {
  constructor(baseUrl, username, appPassword) {
    this.baseUrl = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
    this.username = username;
    this.appPassword = appPassword;
    this.client = axios.create({
      baseURL: this.baseUrl,
      auth: {
        username: this.username,
        password: this.appPassword,
      },
    });
  }

  /**
   * Extract repository and PR info from URL
   * @param {string} url - The Bitbucket PR URL
   * @returns {Object} - Repository and PR information
   */
  parsePrUrl(url) {
    // Handle Bitbucket Server URLs like:
    // https://bitbucket.example.com/projects/PROJECT/repos/REPO/pull-requests/123
    const regex = /\/projects\/([^\/]+)\/repos\/([^\/]+)\/pull-requests\/(\d+)/;
    const matches = url.match(regex);

    if (!matches) {
      throw new Error("Invalid Bitbucket PR URL format");
    }

    return {
      projectKey: matches[1],
      repoSlug: matches[2],
      prId: matches[3],
    };
  }

  /**
   * Fetch PR details from Bitbucket
   * @param {string} url - The Bitbucket PR URL
   * @returns {Promise<Object>} - PR details
   */
  async fetchPRDetails(url) {
    try {
      const { projectKey, repoSlug, prId } = this.parsePrUrl(url);

      // Fetch PR details
      const prEndpoint = `/rest/api/1.0/projects/${projectKey}/repos/${repoSlug}/pull-requests/${prId}`;
      const prResponse = await this.client.get(prEndpoint);

      // Fetch PR changes
      const changesEndpoint = `${prEndpoint}/changes`;
      const changesResponse = await this.client.get(changesEndpoint);

      // Fetch PR comments
      const commentsEndpoint = `${prEndpoint}/activities`;
      const commentsResponse = await this.client.get(commentsEndpoint);

      return {
        prDetails: prResponse.data,
        changes: changesResponse.data,
        comments: commentsResponse.data,
      };
    } catch (error) {
      console.error("Error fetching PR details:", error.message);
      if (error.response) {
        console.error("API Response Error:", error.response.data);
      }
      throw new Error(`Failed to fetch PR details: ${error.message}`);
    }
  }

  /**
   * Generate an AI-enhanced summary using Claude
   * @param {Object} prData - The complete PR data
   * @param {string} baseSummary - The base summary generated by rule-based system
   * @param {string} claudeApiKey - Claude API key
   * @returns {Promise<string>} - Claude-enhanced summary
   */
  async generateClaudeSummary(prData, baseSummary, claudeApiKey) {
    // Early return if no API key
    if (!claudeApiKey) {
      return baseSummary;
    }

    try {
      // Create Claude processor
      const claude = new ClaudeProcessor({
        apiKey: claudeApiKey,
        model: "claude-3-haiku-20240307", // Use a smaller, faster model for PR summaries
        maxTokens: 1000,
        temperature: 0.3, // Lower temperature for more focused response
      });

      // Extract PR information for Claude
      const { prDetails, changes } = prData;
      const title = prDetails.title;
      const description = prDetails.description || "";
      const author = prDetails.author.user.displayName;
      const status = prDetails.state;
      const sourceRef = prDetails.fromRef.displayId;
      const targetRef = prDetails.toRef.displayId;

      // Collect changed files information
      const changedFiles = [];
      if (changes && changes.values) {
        changes.values.forEach((change) => {
          const filePath = change.path.toString;
          // Simplify addition and truncate for brevity
          if (changedFiles.length < 20) {
            changedFiles.push(filePath);
          }
        });
      }

      // Build the prompt for Claude
      const systemPrompt = `You are an expert software engineer analyzing a pull request on Bitbucket. 
Your task is to generate an insightful, concise summary of the PR's changes and purpose.

First, I'll give you the basic PR information and a base summary that was already generated.
Your job is to:
1. Enhance this summary with additional technical insights
2. Identify patterns in the changes that might not be obvious
3. Clarify the overall purpose and impact of the changes
4. Note any potential areas that might need special attention (performance, security, etc.)

Keep your response concise and focused on what would be most useful to a developer looking at this PR later.
Format your response as plain text that explains the changes in simple, clear language.

Exclude any preamble like "Here's my analysis" or "I've reviewed the PR". 
Begin directly with your enhanced summary.`;

      // User message with PR details
      const userMessage = `PR Information:
Title: ${title}
Description: ${description}
Status: ${status}
Author: ${author}
Source Branch: ${sourceRef}
Target Branch: ${targetRef}

Changed Files (${changedFiles.length} total):
${changedFiles.length <= 20 ? changedFiles.join("\n") : changedFiles.join("\n") + "\n... and more"}

Base Summary (already generated):
${baseSummary}

Please enhance this summary with deeper technical insights and a clearer explanation of this PR's purpose and impact.`;

      // Call Claude API
      const response = await axios.post(
        claude.config.apiEndpoint,
        {
          model: claude.config.model,
          max_tokens: claude.config.maxTokens,
          temperature: claude.config.temperature,
          system: systemPrompt,
          messages: [{ role: "user", content: userMessage }],
        },
        {
          headers: {
            "Content-Type": "application/json",
            "x-api-key": claude.config.apiKey,
            "anthropic-version": "2023-06-01",
          },
        },
      );

      // Extract and format the enhanced summary
      const enhancedSummary = response.data.content[0].text.trim();

      // Combine the base summary with Claude's enhanced version
      return `${baseSummary}\n\n## AI-Enhanced Analysis\n${enhancedSummary}`;
    } catch (error) {
      console.warn("Error generating Claude summary:", error.message);
      // Return the original summary if Claude processing fails
      return baseSummary;
    }
  }

  /**
   * Generate a meaningful summary of the PR changes
   * @param {string} title - PR title
   * @param {string} description - PR description
   * @param {Array} changedFileNames - Names of changed files
   * @param {Array} changedFilePaths - Paths of changed files
   * @param {Array} fileTypes - Detected file types
   * @param {Array} tags - Generated tags
   * @returns {string} - Generated summary
   */
  generateChangeSummary(
    title,
    description,
    changedFileNames,
    changedFilePaths,
    fileTypes,
    tags,
  ) {
    // Initialize summary components
    const components = [];

    // Extract the most common directories affected
    const directories = new Map();
    changedFilePaths.forEach((filePath) => {
      const dir = path.dirname(filePath);
      if (dir !== ".") {
        const dirParts = dir.split("/");
        // Consider up to 2 levels of directories for categorization
        const mainDir = dirParts
          .slice(0, Math.min(2, dirParts.length))
          .join("/");
        directories.set(mainDir, (directories.get(mainDir) || 0) + 1);
      }
    });

    // Get top directories (up to 3)
    const topDirs = Array.from(directories.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([dir]) => dir);

    // Generate a summary based on the PR title, description, and files changed
    let summary = "";

    // Step 1: Look for indicators in the title
    const titleLower = title.toLowerCase();
    if (titleLower.includes("fix") || titleLower.includes("bug")) {
      summary += "This PR fixes ";
    } else if (titleLower.includes("add") || titleLower.includes("feature")) {
      summary += "This PR implements ";
    } else if (
      titleLower.includes("update") ||
      titleLower.includes("improve")
    ) {
      summary += "This PR updates ";
    } else if (titleLower.includes("refactor")) {
      summary += "This PR refactors ";
    } else {
      summary += "This PR changes ";
    }

    // Add what was changed based on title or common pattern
    if (
      titleLower.startsWith("fix:") ||
      titleLower.startsWith("feat:") ||
      titleLower.startsWith("chore:") ||
      titleLower.startsWith("docs:") ||
      titleLower.startsWith("refactor:") ||
      titleLower.startsWith("test:")
    ) {
      // Use the title content after the prefix
      const colonIndex = title.indexOf(":");
      if (colonIndex !== -1 && colonIndex < title.length - 1) {
        summary += title
          .substring(colonIndex + 1)
          .trim()
          .toLowerCase();
      } else {
        summary += title.toLowerCase();
      }
    } else {
      summary += title.toLowerCase();
    }

    // Step 2: Add details about affected areas
    if (topDirs.length > 0) {
      summary += `. Primarily affects ${topDirs.join(", ")} directories`;
    }

    // Step 3: Mention relevant technologies
    if (fileTypes.length > 0) {
      const significantTypes = fileTypes
        .filter((type) => !["documentation", "config"].includes(type))
        .slice(0, 3);

      if (significantTypes.length > 0) {
        summary += `. Involves ${significantTypes.join(", ")} code`;
      }
    }

    // Step 4: Extract key points from description if available
    if (description && description.length > 0) {
      // Look for explicit sections in the description
      const sections = {
        changes: null,
        why: null,
        summary: null,
        notes: null,
        motivation: null,
        details: null,
      };

      // Try to extract structured sections
      Object.keys(sections).forEach((sectionName) => {
        const pattern = new RegExp(
          `\\b${sectionName}\\b[:\\s]+(.*?)(?=\\n\\s*\\n|\\n\\s*#|$)`,
          "si",
        );
        const match = description.match(pattern);
        if (match) {
          sections[sectionName] = match[1].trim();
        }
      });

      // Use the first found section (in order of preference)
      const foundSection = [
        "summary",
        "changes",
        "why",
        "motivation",
        "details",
        "notes",
      ].find((section) => sections[section]);

      if (foundSection) {
        // Extract a concise sentence or two from the section
        const sectionText = sections[foundSection];
        const sentences = sectionText
          .split(/[.!?]/)
          .filter((s) => s.trim().length > 0);

        if (sentences.length > 0) {
          // Take up to 2 sentences from the section
          const excerpt = sentences.slice(0, 2).join(". ").trim() + ".";
          summary += `\n\nFrom description: "${excerpt}"`;
        }
      } else {
        // No structured sections found, take the first paragraph or sentence
        const firstParagraph = description.split(/\n\s*\n/)[0];
        if (firstParagraph && firstParagraph.length > 0) {
          const sentences = firstParagraph
            .split(/[.!?]/)
            .filter((s) => s.trim().length > 0);
          if (sentences.length > 0) {
            const excerpt = sentences[0].trim() + ".";
            summary += `\n\nFrom description: "${excerpt}"`;
          }
        }
      }
    }

    // Step 5: Include significant files if there are few of them
    if (changedFileNames.length <= 5) {
      summary += `\n\nChanged files: ${changedFileNames.join(", ")}`;
    } else {
      // For many files, include a sampling and count
      const sampleFiles = changedFileNames.slice(0, 3);
      summary += `\n\nChanged ${changedFileNames.length} files including: ${sampleFiles.join(", ")}, ...`;
    }

    return summary;
  }

  /**
   * Process PR data and generate tags
   * @param {Object} prData - PR data
   * @returns {Object} - Processed PR data with tags
   */
  processPRData(prData) {
    const { prDetails, changes, comments } = prData;

    // Extract basic PR info
    const title = prDetails.title;
    const description = prDetails.description || "";
    const author = prDetails.author.user.displayName;
    const status = prDetails.state;
    const createdDate = new Date(prDetails.createdDate);
    const updatedDate = new Date(prDetails.updatedDate);
    const sourceRef = prDetails.fromRef.displayId;
    const targetRef = prDetails.toRef.displayId;
    const url = prDetails.links.self[0].href;

    // Generate automatic tags
    const tags = new Set();

    // Add status tag
    tags.add(status);

    // Add branch tags
    tags.add(`source:${sourceRef}`);
    tags.add(`target:${targetRef}`);

    // Check file types and generate language/tech tags
    const fileExtensions = new Set();
    const fileTypes = new Set();
    const changedFileNames = [];
    const changedFilePaths = [];

    if (changes && changes.values) {
      changes.values.forEach((change) => {
        const filePath = change.path.toString;
        changedFilePaths.push(filePath);
        const fileName = path.basename(filePath);
        changedFileNames.push(fileName);
        const fileExt = path.extname(filePath).toLowerCase().replace(".", "");

        if (fileExt) {
          fileExtensions.add(fileExt);

          // Map extensions to broader categories
          if (["js", "jsx", "ts", "tsx"].includes(fileExt)) {
            fileTypes.add("javascript");
            if (["ts", "tsx"].includes(fileExt)) {
              fileTypes.add("typescript");
            }
            if (["jsx", "tsx"].includes(fileExt)) {
              fileTypes.add("react");
            }
          } else if (["py"].includes(fileExt)) {
            fileTypes.add("python");
          } else if (["java"].includes(fileExt)) {
            fileTypes.add("java");
          } else if (["rb"].includes(fileExt)) {
            fileTypes.add("ruby");
          } else if (["go"].includes(fileExt)) {
            fileTypes.add("golang");
          } else if (["php"].includes(fileExt)) {
            fileTypes.add("php");
          } else if (["html", "htm"].includes(fileExt)) {
            fileTypes.add("html");
          } else if (["css", "scss", "sass", "less"].includes(fileExt)) {
            fileTypes.add("css");
            if (["scss", "sass"].includes(fileExt)) {
              fileTypes.add("sass");
            }
            if (["less"].includes(fileExt)) {
              fileTypes.add("less");
            }
          } else if (["md", "markdown"].includes(fileExt)) {
            fileTypes.add("documentation");
          } else if (["json", "yaml", "yml", "toml"].includes(fileExt)) {
            fileTypes.add("config");
          } else if (["sql"].includes(fileExt)) {
            fileTypes.add("database");
          }
        }

        // Detect specific file patterns
        if (filePath.includes("test") || filePath.includes("spec")) {
          fileTypes.add("tests");
        }
        if (
          filePath.endsWith("package.json") ||
          filePath.endsWith("package-lock.json")
        ) {
          fileTypes.add("npm");
        }
        if (filePath.includes("docker") || filePath.endsWith("Dockerfile")) {
          fileTypes.add("docker");
        }
        if (filePath.includes("k8s") || filePath.includes("kubernetes")) {
          fileTypes.add("kubernetes");
        }
      });
    }

    // Add file type tags
    fileTypes.forEach((type) => tags.add(type));

    // Extract keywords from title and description
    const combinedText = `${title} ${description}`.toLowerCase();
    const commonKeywords = [
      "fix",
      "feature",
      "update",
      "improve",
      "refactor",
      "bug",
      "tests",
      "security",
      "performance",
      "ui",
      "ux",
      "frontend",
      "backend",
      "api",
      "database",
      "authentication",
      "authorization",
      "deployment",
    ];

    commonKeywords.forEach((keyword) => {
      if (combinedText.includes(keyword)) {
        tags.add(keyword);
      }
    });

    // Generate statistics about changes
    const changedFiles = changes && changes.values ? changes.values.length : 0;
    const commentCount =
      comments && comments.values
        ? comments.values.filter((a) => a.action === "COMMENTED").length
        : 0;

    // Generate a summary of the changes
    const changeSummary = this.generateChangeSummary(
      title,
      description,
      changedFileNames,
      changedFilePaths,
      Array.from(fileTypes),
      Array.from(tags),
    );

    // Format the data
    return {
      title,
      description,
      author,
      status,
      createdDate,
      updatedDate,
      sourceRef,
      targetRef,
      url,
      changedFiles,
      commentCount,
      changeSummary,
      changedFileNames,
      changedFilePaths,
      tags: Array.from(tags),
      fileExtensions: Array.from(fileExtensions),
      fileTypes: Array.from(fileTypes),
    };
  }

  /**
   * Save PR details as a thought
   * @param {string} url - PR URL
   * @param {string} thoughtsDir - Directory to save thoughts
   * @param {Object} options - Additional options
   * @returns {Promise<Object>} - Saved thought details
   */
  async savePRAsThought(url, thoughtsDir, options = {}) {
    try {
      // Fetch PR details
      const prData = await this.fetchPRDetails(url);

      // Process PR data
      const processedData = this.processPRData(prData);

      // Get custom tags from options
      const customTags = options.tags
        ? options.tags.split(",").map((t) => t.trim())
        : [];
      const allTags = [...processedData.tags, ...customTags];

      // Format the thought content
      const timestamp = new Date().toISOString();
      const formattedDate = format(processedData.createdDate, "yyyy-MM-dd");

      // Create a safe filename
      const safeTitle = slugify(processedData.title, {
        lower: true,
        strict: true,
      });
      const filename = `${timestamp.replace(/[:.]/g, "-")}-pr-${safeTitle}.md`;
      const filepath = path.join(thoughtsDir, filename);

      // Generate AI-enhanced summary if Claude API key is provided
      let enhancedSummary = processedData.changeSummary;
      if (options.claudeApiKey) {
        console.log(
          chalk.blue("Generating AI-enhanced summary with Claude..."),
        );
        enhancedSummary = await this.generateClaudeSummary(
          prData,
          processedData.changeSummary,
          options.claudeApiKey,
        );
        processedData.aiEnhancedSummary = true;
      }

      // Generate thought content
      const thoughtContent = `# ${processedData.title} (PR)

## Change Summary
${processedData.aiEnhancedSummary ? enhancedSummary : processedData.changeSummary || "*No summary generated*"}
${processedData.aiEnhancedSummary ? "\n*Summary enhanced with Claude AI*" : ""}

## PR Information
- **URL**: [${url}](${url})
- **Status**: ${processedData.status}
- **Author**: ${processedData.author}
- **Created**: ${format(processedData.createdDate, "yyyy-MM-dd HH:mm:ss")}
- **Last Updated**: ${format(processedData.updatedDate, "yyyy-MM-dd HH:mm:ss")}
- **Source Branch**: ${processedData.sourceRef}
- **Target Branch**: ${processedData.targetRef}
- **Files Changed**: ${processedData.changedFiles}
- **Comments**: ${processedData.commentCount}

## Description
${processedData.description || "*No description provided*"}

## Changed Files
${
  processedData.changedFilePaths.length <= 15
    ? processedData.changedFilePaths.map((file) => `- ${file}`).join("\\n")
    : processedData.changedFilePaths
        .slice(0, 15)
        .map((file) => `- ${file}`)
        .join("\\n") +
      `\\n- ... and ${processedData.changedFilePaths.length - 15} more files`
}

## Tags
${allTags.map((tag) => `- ${tag}`).join("\\n")}

## File Types
${processedData.fileTypes.map((type) => `- ${type}`).join("\\n")}

${options.notes ? `## Notes\n${options.notes}` : ""}

---
*PR saved on ${format(new Date(), "yyyy-MM-dd HH:mm:ss")}*
`;

      // Save the thought
      await fs.writeFile(filepath, thoughtContent);

      // Index the PR in the PR database
      await this.indexPR(thoughtsDir, {
        id: uuidv4(),
        url,
        title: processedData.title,
        author: processedData.author,
        status: processedData.status,
        createdDate: processedData.createdDate,
        savedDate: new Date(),
        tags: allTags,
        fileTypes: processedData.fileTypes,
        summary: processedData.aiEnhancedSummary
          ? enhancedSummary
          : processedData.changeSummary,
        aiEnhancedSummary: processedData.aiEnhancedSummary || false,
        changedFiles: processedData.changedFiles,
        commentCount: processedData.commentCount,
        changedFileNames: processedData.changedFileNames.slice(0, 10), // Store a sample of files
        thoughtFile: filename,
      });

      return {
        success: true,
        filepath,
        filename,
        title: processedData.title,
        tags: allTags,
      };
    } catch (error) {
      console.error("Error saving PR as thought:", error);
      throw error;
    }
  }

  /**
   * Save PR info to the PR index database
   * @param {string} thoughtsDir - Directory to save thoughts
   * @param {Object} prInfo - PR information to save
   * @returns {Promise<void>}
   */
  async indexPR(thoughtsDir, prInfo) {
    const prDbPath = path.join(thoughtsDir, ".pr_index.json");

    try {
      // Check if PR database exists, create it if it doesn't
      let prDatabase = [];
      try {
        const dbContent = await fs.readFile(prDbPath, "utf8");
        prDatabase = JSON.parse(dbContent);
      } catch (error) {
        // Database doesn't exist yet, will create it
      }

      // Add PR to database
      prDatabase.push(prInfo);

      // Save updated database
      await fs.writeFile(prDbPath, JSON.stringify(prDatabase, null, 2));
    } catch (error) {
      console.error("Error indexing PR:", error);
      throw error;
    }
  }

  /**
   * Search for PRs in the index
   * @param {string} thoughtsDir - Directory where thoughts are stored
   * @param {Object} query - Search query
   * @returns {Promise<Array>} - Matching PRs
   */
  async searchPRs(thoughtsDir, query = {}) {
    const prDbPath = path.join(thoughtsDir, ".pr_index.json");

    try {
      // Read PR database
      let prDatabase = [];
      try {
        const dbContent = await fs.readFile(prDbPath, "utf8");
        prDatabase = JSON.parse(dbContent);
      } catch (error) {
        // Database doesn't exist or can't be read
        return [];
      }

      // Filter PRs based on query
      let results = [...prDatabase];

      if (query.text) {
        const searchText = query.text.toLowerCase();
        results = results.filter(
          (pr) =>
            pr.title.toLowerCase().includes(searchText) ||
            (pr.summary && pr.summary.toLowerCase().includes(searchText)) ||
            pr.tags.some((tag) => tag.toLowerCase().includes(searchText)) ||
            pr.fileTypes.some((type) =>
              type.toLowerCase().includes(searchText),
            ) ||
            (pr.changedFileNames &&
              pr.changedFileNames.some((file) =>
                file.toLowerCase().includes(searchText),
              )),
        );
      }

      if (query.tag) {
        results = results.filter((pr) =>
          pr.tags.some((tag) => tag.toLowerCase() === query.tag.toLowerCase()),
        );
      }

      if (query.author) {
        results = results.filter((pr) =>
          pr.author.toLowerCase().includes(query.author.toLowerCase()),
        );
      }

      if (query.status) {
        results = results.filter(
          (pr) => pr.status.toLowerCase() === query.status.toLowerCase(),
        );
      }

      if (query.fileType) {
        results = results.filter((pr) =>
          pr.fileTypes.some(
            (type) => type.toLowerCase() === query.fileType.toLowerCase(),
          ),
        );
      }

      // Add a relevance score for better sorting when searching
      if (query.text) {
        const searchText = query.text.toLowerCase();
        results.forEach((pr) => {
          let relevance = 0;

          // Higher score for exact title matches
          if (pr.title.toLowerCase().includes(searchText)) {
            relevance += 10;
            // Even higher for title starts with
            if (pr.title.toLowerCase().startsWith(searchText)) {
              relevance += 5;
            }
          }

          // Good score for summary matches
          if (pr.summary && pr.summary.toLowerCase().includes(searchText)) {
            relevance += 8;
          }

          // Score for tag matches
          if (pr.tags.some((tag) => tag.toLowerCase().includes(searchText))) {
            relevance += 7;
          }

          // Score for file type matches
          if (
            pr.fileTypes.some((type) => type.toLowerCase().includes(searchText))
          ) {
            relevance += 6;
          }

          // Score for filename matches
          if (
            pr.changedFileNames &&
            pr.changedFileNames.some((file) =>
              file.toLowerCase().includes(searchText),
            )
          ) {
            relevance += 5;
          }

          pr.relevance = relevance;
        });

        // Sort by relevance first, then by date
        results.sort((a, b) => {
          if (a.relevance !== b.relevance) {
            return b.relevance - a.relevance; // Higher relevance first
          }
          return new Date(b.savedDate) - new Date(a.savedDate); // Then newer first
        });
      } else {
        // If not searching text, sort by date (newest first)
        results.sort((a, b) => new Date(b.savedDate) - new Date(a.savedDate));
      }

      // Apply limit if specified
      if (query.limit && !isNaN(parseInt(query.limit))) {
        results = results.slice(0, parseInt(query.limit));
      }

      return results;
    } catch (error) {
      console.error("Error searching PRs:", error);
      return [];
    }
  }

  /**
   * Get a list of all tags used in indexed PRs
   * @param {string} thoughtsDir - Directory where thoughts are stored
   * @returns {Promise<Array>} - List of unique tags
   */
  async getAllTags(thoughtsDir) {
    const prDbPath = path.join(thoughtsDir, ".pr_index.json");

    try {
      // Read PR database
      let prDatabase = [];
      try {
        const dbContent = await fs.readFile(prDbPath, "utf8");
        prDatabase = JSON.parse(dbContent);
      } catch (error) {
        // Database doesn't exist or can't be read
        return [];
      }

      // Extract and count all tags
      const tagCounts = {};
      prDatabase.forEach((pr) => {
        pr.tags.forEach((tag) => {
          if (tagCounts[tag]) {
            tagCounts[tag]++;
          } else {
            tagCounts[tag] = 1;
          }
        });
      });

      // Convert to array of objects with tag and count
      return Object.entries(tagCounts)
        .map(([tag, count]) => ({
          tag,
          count,
        }))
        .sort((a, b) => b.count - a.count);
    } catch (error) {
      console.error("Error getting tags:", error);
      return [];
    }
  }
}

/**
 * Create a new BitbucketProcessor instance
 * @param {Object} config - Configuration object with baseUrl, username, and appPassword
 * @returns {BitbucketProcessor} - BitbucketProcessor instance
 */
export function createBitbucketProcessor(config) {
  return new BitbucketProcessor(
    config.baseUrl,
    config.username,
    config.appPassword,
  );
}

